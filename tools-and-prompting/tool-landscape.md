---
description: Picking the Right Weapon (Not Worshipping One)
---

# Tool Landscape

Cursor is not the only option.\
It is simply the **best starting point for this workshop** because it embeds AI directly into the IDE.

> Good engineers do not marry tools.\
> They **choose tools based on intent**.

### IDE-Centric AI Tools (Primary Execution Layer)

These tools operate **inside or alongside the editor**.\
They are used for **day-to-day development velocity**.

<details>

<summary><strong>Cursor</strong></summary>

**Best for:**

* Full-project context
* Multi-file reasoning
* Refactors and architectural awareness
* Debugging and PR-level thinking

**When to use:**

* Active feature development
* Complex refactors
* Understanding unfamiliar codebases

</details>

<details>

<summary><strong>GitHub Copilot</strong></summary>

**Best for:**

* Inline code completion
* Small repetitive logic
* Language-level familiarity

**Limitations:**

* Weak architectural awareness
* Poor at multi-file reasoning

**When to use:**

* Writing boilerplate
* Filling predictable patterns
* Speeding up routine coding

</details>

<details>

<summary><strong>Windsurf</strong></summary>

**Best for:**

* Fast iteration with conversational coding
* Rapid prototyping
* Exploratory changes

**Limitations:**

* Less strict control
* Can drift without guardrails

**When to use:**

* Proof-of-concepts
* Early-stage experiments
* Short-lived branches

</details>

<details>

<summary>Codeium</summary>

**Best for:**

* Free alternative to Copilot
* Lightweight autocomplete
* Teams with licensing constraints

**When to use:**

* Cost-sensitive environments
* Supplementing basic IDE intelligence

</details>

### Reasoning and Deep Analysis Tools (Thinking Layer)

These tools are **not for writing code first**.\
They are for **understanding problems deeply**.

<details>

<summary>OpenAI Codex / Advanced Reasoning Models</summary>

**Best for:**

* Algorithm analysis
* Edge-case exploration
* System design validation

**When to use:**

* Before writing complex logic
* Evaluating trade-offs
* Reviewing risky changes

</details>

<details>

<summary><strong>Antigravity</strong></summary>

**Best for:**

* Cross-codebase understanding
* High-level architectural mapping
* Impact analysis

**When to use:**

* Large legacy systems
* Onboarding into unfamiliar products
* Understanding the blast radius of changes

</details>

### Research and Exploration Tools (R\&D Layer)

These tools are for **learning and discovery**, not shipping code.

<details>

<summary>ChatGPT / Claude (Browser or Ask Mode)</summary>

**Best for:**

* Concept clarification
* API comparisons
* Design pattern exploration

**When to use:**

* Early investigation
* Non-code questions
* Learning unfamiliar domains

</details>

***

### Key Rule. Tool Juggling Is a Skill

Using multiple AI tools is not a problem.\
Using them **without structure** is.

Bad engineers:

* Randomly switch tools
* Repeat the same prompts
* Trust outputs blindly

Good engineers:

* Assign **roles** to tools
* Keep context localized
* Validate before acting

> **IDE tools execute.**\
> **Reasoning tools think.**\
> **Research tools explore.**

If you mix these roles, productivity collapses.

***

### Transition Back to Cursor

Now that we understand the **tool landscape**, we intentionally start with **Cursor**.

**Why?**

* It enforces context discipline
* It lives where engineers already work
* It scales from small tasks to architectural reasoning

Next, we break down **Cursor modes** and how to use each one **without losing control**.
